## Конструкторы списков

Конструкторы списков (lists comprehension) -- еще один высокоуровневый способ работы с коллекциями.

Они позволяют делать многое из того, что делается рассмотренными раньше функциями map и filter, но в более лаконичном синтаксисе.

Пример map:

```elixir-iex
> users
[
  {:user, 1, "Bob", 23},
  {:user, 2, "Helen", 20},
  {:user, 3, "Bill", 15},
  {:user, 4, "Kate", 14}
]
> for {:user, id, name, _age} <- users, do: {id, name}
[{1, "Bob"}, {2, "Helen"}, {3, "Bill"}, {4, "Kate"}]
```

Пример filter:

```elixir-iex
> for {:user, _id, _name, age} = user <- users, age > 16, do: user
[{:user, 1, "Bob", 23}, {:user, 2, "Helen", 20}]

> for {:user, _id, _name, age} = user <- users, age > 40, do: user
...
```

Конструкторы списков позволяют объединять map и filter в одном проходе:

```elixir-iex
> for {:user, _id, name, age} <- users, age > 16, do: name
["Bob", "Helen"]
```

Конструкторы списков позволяют обрабатывать несколько списков одновременно:

```elixir-iex
> list_1 = [1, 2, 3, 4]
> list_2 = [:a, :b, :c]
> for x <- list_1, y <- list_2, do: {x, y}

> list_3 = ["hello", "world"]
> for x <- list_1, y <- list_2, z <- list_3, do: {x, y, z}
[
  {1, :a, "hello"},
  ...
  {4, :c, "world"}
]
```

Как видно, элементы списков соединяются "каждый с каждым".

Ну, и, конечно, все эти списки можно фильтровать:

```elixir-iex
> for x <- list_1, y <- list_2, z <- list_3, x > 2, y != :b, do: {x, y, z}
[
  {3, :a, "hello"},
  {3, :a, "world"},
  {3, :c, "hello"},
  {3, :c, "world"},
  {4, :a, "hello"},
  {4, :a, "world"},
  {4, :c, "hello"},
  {4, :c, "world"}
]
```

## Синтаксис

Синтаксис конструкторов списков не очень сложный, но с ним нужно разобраться.

```elixir
result = for generator, generator, filter, filter, ... [, into: value ], do: expression
```

Генератор имеет вид:

```
pattern <- collection
```

Коллекция может быть любой структурой данных, реализующей протокол Enumerable. Каждый элемент коллекции сопоставляется с шаблоном, и если не происходит совпадения, то этот элемент отбрасывается.

```elixir-iex
> animals = [{:cat, "Cat A"}, {:dog, "Dog B"}, {:cat, "Cat C"}, {:dog, "Dog E"}]
[cat: "Cat A", dog: "Dog B", cat: "Cat C", dog: "Dog E"]
> for {:cat, name} <- animals, do: name
["Cat A", "Cat C"]
```

Фильтр представляет собой функцию-предикат. Она принимает текущий элемент и возвращает булевое значение. Фильтры мы уже видели выше.

`into` позволяет добавить результ генератора списка в существующую коллецию. Это может быть полезно, например, для map:

```elixir-iex
> data = %{a: 1, b: 2}
%{a: 1, b: 2}
> for {k, v} <- [{:c, 3}, {:d, 4}, {:cat, "Cat A"}, :boom], into: data, do: {k, v}
%{a: 1, b: 2, c: 3, cat: "Cat A", d: 4}
```

И последний элемент синтаксиса, блок do, определяет, как нужно преобразовать промежуточные элементы в конечный результат.

Для примера выведем таблицу умножения:

```elixir-iex
> for x <- 1..5, y <- 1..5, do: {x, y, x * y}

> for x <- 1..5, y <- 1..5, do: "#{x} * #{y} = #{x * y}"
["1 * 1 = 1", "1 * 2 = 2", "1 * 3 = 3", "1 * 4 = 4", "1 * 5 = 5", "2 * 1 = 2",
 "2 * 2 = 4", "2 * 3 = 6", "2 * 4 = 8", "2 * 5 = 10", "3 * 1 = 3", "3 * 2 = 6",
 "3 * 3 = 9", "3 * 4 = 12", "3 * 5 = 15", "4 * 1 = 4", "4 * 2 = 8",
 "4 * 3 = 12", "4 * 4 = 16", "4 * 5 = 20", "5 * 1 = 5", "5 * 2 = 10",
 "5 * 3 = 15", "5 * 4 = 20", "5 * 5 = 25"]
```

## Пифагоровы тройки

Ну и напоследок красивый пример из книги Джо Армстронга с пифагоровыми тройками. Вспомним теорему Пифагора: сумма квадратов катетов равна квадрату гипотенузы. Существует не так много вариантов, когда длины катетов и гипотенузы выражаются целыми числами. Самый известный такой вариант: `{3, 4, 5}`.

Армстронг предлагает найти все такие варианты с помощью конструкторов списков.  На входе дана максимальная длина гипотенузы, на выходе нужно получить список всех возможных троек **{Катет, Катет, Гипотенуза}**, где длины являются целыми числами.

Берем список всех возможных длин:

```elixir-iex
> max_length = 20
20
> lengthes = 1..max_length
```

И генерируем все возможные сочетания длин:

```elixir-iex
> for x <- lengthes, y <- lengthes, z <- lengthes, do: {x, y, z}
[
  {1, 1, 1},
 ...
```

Промежуточный результат получится очень большой, но это не важно. Дальше его нужно отфильтровать.

```elixir-iex
> for x <- lengthes, y <- lengthes, z <- lengthes, x * x + y * y == z * z, do: {x, y, z}
[
  {3, 4, 5},
  {4, 3, 5},
  {5, 12, 13},
  {6, 8, 10},
  {8, 6, 10},
  {8, 15, 17},
  {9, 12, 15},
  {12, 5, 13},
  {12, 9, 15},
  {12, 16, 20},
  {15, 8, 17},
  {16, 12, 20}
]
```

Хорошо бы еще устранить дубликаты. Для этого добавим еще один фильтр.

```elixir-iex
> for x <- lengthes, y <- lengthes, z <- lengthes,
> x < y,
> x * x + y * y == z * z,
> do: {x, y, z}
[{3, 4, 5}, {5, 12, 13}, {6, 8, 10}, {8, 15, 17}, {9, 12, 15}, {12, 16, 20}]
```

Задача решена одной строкой кода :)
