# Модуль Enum

[Модуль Enum](https://hexdocs.pm/elixir/Enum.html) -- основной способ работы с коллекциями. Он содержит уже известные нам функции map, filter, reduce, и еще несколько десятков других функций.

Рассмотрим некоторые из них. Но прежде разберемся, что такое "коллекции".

Коллекциями являются не только списки, но и многие другие типы данных: String, Map, MapSet, Range. Они по-разному устроены, но предоставляют общий АПИ, благодаря которому модуль Enum может работать со всеми ними одинаково.

Этот АПИ называется протокол **Enumerable**. Протоколы мы будем рассматривать позже. Сейчас важно знать, что для разных структуры данных можно реализовать одинаковый протокол, что дает нам полиморфизм. Это похоже на то, как работают интерфейсы в Java.


## sort

Начнем с сортировки. В BEAM любые значения можно сравнивать между собой, даже значения разных типов. Сравнение внутри одного типа удивления не вызывает, но как сравнить атом и кортеж? В BEAM принята некоторая иерархия типов, в рамках которой считается, что любой атом больше любого числа. В целом это выглядит так:

number < atom < reference < function < port < pid < list < tuple < map < bitstring

Так что мы можем сортировать что угодно:

```elixir-iex
> Enum.sort([1, 31, 5, 3.14, 6])
[1, 3.14, 5, 6, 31]
> Enum.sort([:hello, 42, {1, 2}, "world", fn x -> x end, %{:a => 42}, 555])
[
  42,
  555,
  :hello,
  #Function<44.97283095/1 in :erl_eval.expr/5>,
  {1, 2},
  %{a: 42},
  "world"
]
```

Однако, чаще нам нужно сравнивать пользовательские типы данных, для которых нужно указать свои правила сортировки. Например, список пользователей мы хотели бы сортировать по имени. Для этого в Enum.sort нужно передать свою функцию, которая получает два элемента из списка и сообщает, какой из них больше. Функция должна вернуть true, если первый элемент меньше или равен второму, и false, если первый элемент больше второго:

```elixir-iex
> users = HOF.test_data
[
  {:user, 1, "Bob", 23},
  {:user, 2, "Helen", 20},
  {:user, 3, "Bill", 15},
  {:user, 4, "Kate", 14}
]
> sorter = fn({:user, _, name1, _}, {:user, _, name2, _}) -> name1 <= name2 end
#Function<43.97283095/2 in :erl_eval.expr/5>
> Enum.sort(users, sorter)
[
  {:user, 3, "Bill", 15},
  {:user, 1, "Bob", 23},
  {:user, 2, "Helen", 20},
  {:user, 4, "Kate", 14}
]
```

TODO HOF.sort_by/2

TODO HOF.sort_by/3

Здесь используется invert/1 -- функция которая принимает функцию и возвращает функцию. Второе не часто используется на практике. Но вот хороший пример, где это полезно.


## zip

В функциональном программировании не редко встречается задача, когда нужно взять два списка и как-то объединить их элементы попарно. Это делает функция `Enum.zip/2`. В простом варианте она просто соединяет элементы в кортеж:

```elixir-iex
> Enum.zip([1, 2, 3, 4], [:a, :b, :c, :d])
[{1, :a}, {2, :b}, {3, :c}, {4, :d}]
```

Списки могут быть разной длины, тогда zip завершится вместе с коротким списком:

```elixir-iex
> Enum.zip([1, 2], [:a, :b, :c, :d])
[{1, :a}, {2, :b}]
> Enum.zip([1, 2, 3, 4], [:a, :b, :c])
[{1, :a}, {2, :b}, {3, :c}]
```

Иногда мы хотим не просто объединить два элемента в кортеж, но как-то вычислить новый элемент на основе первых двух. Это можно сделать в два прохода -- zip и map:

```elixir-iex
> users
[
  {:user, 1, "Bob", 23},
  {:user, 2, "Helen", 20},
  {:user, 3, "Bill", 15},
  {:user, 4, "Kate", 14}
]
> Enum.zip([10, 20, 30, 40], users)
[
  {10, {:user, 1, "Bob", 23}},
  {20, {:user, 2, "Helen", 20}},
  {30, {:user, 3, "Bill", 15}},
  {40, {:user, 4, "Kate", 14}}
]
> set_id = fn({id, {:user, _, name, age}}) -> {:user, id, name, age} end
#Function<44.97283095/1 in :erl_eval.expr/5>
> Enum.zip([10, 20, 30, 40], users) |> Enum.map(set_id)
[
  {:user, 10, "Bob", 23},
  {:user, 20, "Helen", 20},
  {:user, 30, "Bill", 15},
  {:user, 40, "Kate", 14}
]
```

Но можно использовать функцию Enum.zip_with/3:

```elixir-iex
> set_id = fn(id, {:user, _, name, age}) -> {:user, id, name, age} end
#Function<43.97283095/2 in :erl_eval.expr/5>
> Enum..zip_with([10, 20, 30, 40], users, set_id)
[
  {:user, 10, "Bob", 23},
  {:user, 20, "Helen", 20},
  {:user, 30, "Bill", 15},
  {:user, 40, "Kate", 14}
]
```

Тут есть небольшое отличие: set_id должна принимать два аргумента, а не кортеж из двух элементов.


## group_by

Еще одна нередкая задача -- сгруппировать элементы списка по какому-нибудь ключу. Собственно, мы это уже делали, когда делили список пользователей на две группы по возрасту.

Сделаем то же самое с помощью Enum.group_by:

```
  def group_users(users) do
    grouper = fn {:user, _, _, age} ->
      cond do
        age <= 14 -> :child
        age > 14 and age <= 17 -> :teen
        age > 17 -> :adult
      end
    end

    Enum.group_by(users, grouper)
  end
```

```elixir-iex
> users = HOF.test_data
> HOF.group_users(users)
```

Для каждого элемента списка функция должна определить, к какому ключу он принадлежит. На выходе получится map, где собраны все ключи, и по каждому ключу можно получить список значений, которые к нему относятся.


## chunk_every

TODO это не HOF. Нужен пример `chunk_by` или `chunk_while`

Еще одна полезная функция, которая позволяет разбить список на вложенные списки определенного размера. Это удобно при потоковой обработке входящих данных, когда мы хотим обрабатывать эти данные не по одному элементу, а группами по несколько элементов (батчами, чанками). В определенных случаях это увеличивает пропускную способность канала.

```elixir-iex
> data = [1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
> Enum.chunk_every(data, 3)
[[1, 2, 3], [4, 5, 6]]
> Enum.chunk_every(data, 2)
[[1, 2], [3, 4], [5, 6]]
```

Пример чуть сложнее:

```elixir-iex
> input_bytes = "bla-bla-bla bla-bla bla-bla-bla bla"
"bla-bla-bla bla-bla bla-bla-bla bla"
> input_bytes |> String.to_charlist |> Enum.chunk_every(5)
['bla-b', 'la-bl', 'a bla', '-bla ', 'bla-b', 'la-bl', 'a bla']
```


## Другие HOF

TODO: несколько примеров

Enum: `all?/2`, `any?/2`, `count/2`, `drop_while/2` и др
Map: `filter/2`, `merge/3`, `split_with/2`
(same for Keyword module)
