# Функции высшего порядка

Функции во всех функциональных языках являются обычными значениями. Их можно присваивать переменной, передавать в аргументах, возвращать из функции.

Функции высшего порядка (higher-order functions, HOF) -- это функции, которые принимают в аргументах другие функции или возвращают другие функции.

В стандартном модуле **Enum** таких функций много. И самые важные из них, это **map**, **filter** и **reduce**. В других ФП языках (например, в Эрланг) reduce часто называют **fold**. Эти три функции составляют основу применения HOF, и многие другие функции строятся на их базе.

Функции map, filter и reduce реализованы как рекурсия с аккумулятором. Их не сложно реализовать самому.

В большинстве библиотечных функций в Эликсир принят такой порядок аргументов, чтобы их было удобно использовать с оператором pipe. Поэтому список (или другая коллекция) всегда идет первым аргументом.

```
collection
|> Enum.map(fn1)
|> Enum.filter(fn2)
|> Enum.reduce(acc, fn3)
```

Тут Эликсир отличается от Эрланг, где в аналогичных функциях принят другой порядок аргументов:

```
List2 = lists:map(Fn1, List1)
List3 = lists:filter(Fn2, List2)
List4 = lists:foldl(Fn3, Acc, List3)
```


## Map

Функция **Enum.map/2** применяет переданную функцию к каждому элементу списка и возвращает новый список.

```elixir-iex
> lst = [1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
> f = fn i -> i * i end
#Function<44.97283095/1 in :erl_eval.expr/5>
> Enum.map(lst, f)
[1, 4, 9, 16, 25]
```

Вспомним, какие упражнения мы делали на рекурсии с аккумулятором и повторим их с помощью функций высшего порядка.

Для начала нам понадобится тот же список пользователей, с которым мы работали раньше.

```elixir-iex
  def test_data() do
    # {:user, id, name, age}
    [
      {:user, 1, "Bob", 23},
      {:user, 2, "Helen", 20},
      {:user, 3, "Bill", 15},
      {:user, 4, "Kate", 14}
    ]
  end
```

Извлечём id и name пользователей. Нам даже не нужно писать реализацию в модуле, это удобно делать прямо в консоли:

```
f = fn {:user, id, name, _} -> {id, name} end
Enum.map(users, f)
```

Или мы можем преобразовать имя каждого пользователя в верхний регистр:

```
> Enum.map(users, fn({:user, id, name, age}) -> {:user, id, String.upcase(name), age} end)
```

Анонимную функцию чаще всего не присваивают в переменную, а передают прямо в аргументах.


## Filter

**Enum.filter/2** использует переданную функцию, как предикат для фильтрации списка.

```elixir-iex
> Enum.filter([1, 2, 3, 4, 5], fn(i) -> i > 3 end)
[4, 5]
```

Давайте отфильтруем совершеннолетних пользователей:

```elixir-iex
> users = HOF.test_data
[
  {:user, 1, "Bob", 23},
  {:user, 2, "Helen", 20},
  {:user, 3, "Bill", 15},
  {:user, 4, "Kate", 14}
]
> Enum.filter(users, fn({:user, _, _, age}) -> age > 16 end)
[{:user, 1, "Bob", 23}, {:user, 2, "Helen", 20}]
```

Разделим пользователей на два списка: несовершеннолетние и взрослые:

```elixir-iex
> adults = Enum.filter(users, fn({:user, _, _, age}) -> age > 16 end)
[{:user, 1, "Bob", 23}, {:user, 2, "Helen", 20}]
> children = Enum.filter(users, fn({:user, _, _, age}) -> age <= 16 end)
[{:user, 3, "Bill", 15}, {:user, 4, "Kate", 14}]
```

Здесь мы сделали два прохода по списку. Разделение в один проход сделаем немного позже с помощью **Enum.reduce/3**.

В данной реализации граница по возрасту прописана прямо в коде. Давайте сделаем более гибкую реализацию, чтобы граница передавалась внешним аргументом:

```
  def filter_by_age(users, max_age) do
    Enum.filter(users, fn({:user, _, _, age}) -> age < max_age end)
  end
```

Теперь пользователей можно делить по-разному:

```
HOF.filter_by_age(users, 10)
HOF.filter_by_age(users, 20)
HOF.filter_by_age(users, 50)
```
