# Устройство списков

Списки, как и любые другие структуры данных, являются неизменяемыми.

Вот мы создаем список и присваиваем его переменной my_list:

```elixir-iex
iex(1)> my_list = [1, 2, 3, 4]
[1, 2, 3, 4]
```

В памяти у нас появляется вот такая структура:

![Linked list im memory](./img/list_1.png)

4 элемента списка сохраняются в виде пар ссылка + значение, где ссылка указывает на следующий элемент. В последнем элементе ссылка нулевая, никуда не указывает.

Как же нам добавить новый элемент? Этот список мы модифицировать не можем, но можем создать новый список, включающий один новый элемент и все элементы старого списка:

```elixir
iex(2)> my_list = [0 | my_list]
[0, 1, 2, 3, 4]
```

Оператор **`|`** называется **cons**, он добавляет новый элемент в голову списка и возвращает новый список.

![List concatenation](./img/list_2.png)

В новом элементе ссылка указывает на первый элемент списка **my_list**. В самом списке my_list ничего не меняется. Область памяти, которую он занимает, модифицировать не нужно.

Итого, у нас теперь есть два списка. Но при этом расход памяти минимальный, ибо большая ее часть используется обоими списками.

Любой список можно представить как последовательность операторов cons:

```elixir
iex(3)> [0 | [1 | [2 | [3 | [4 | []]]]]]
[0, 1, 2, 3, 4]
```

Или схематически:

![List as set of concatenations](./img/list_3.png)

Оператор cons используется и для добавления элемента в начало списка, и для разделения списка на начальный элемент (голова) и все остальные элементы (хвост).

```elixir-iex
iex(4)> [head | tail] = my_list
[0, 1, 2, 3, 4]
iex(5)> head
0
iex(6)> tail
[1, 2, 3, 4]
```

А что было бы, если бы мы использовали двунаправленный связный список? Он представлен в памяти так:

![Doubly linked list](./img/list_4.png)

Каждый элемент состоит из значения и двух ссылок. Одна ссылка указывает на предыдущий элемент, другая ссылка на следующий элемент.

Попробуем добавить к такому списку новое значение.

![Add element to doubly linked list](./img/list_5.png)

Ссылка в новом элементе указывает на голову списка. Но еще нужно в голове списка поменять ссылку, чтобы она указывала на новый элемент. Поменять ссылку -- это значит, модифицировать память, нарушить ссылочную прозрачность.

Ок, мы можем не модифицировать ссылку в элементе, а скопировать весь элемент:

![Copy element of doubly linked list](./img/list_6.png)

Но теперь нужно менять ссылку в предыдущем элементе. А значит, нужно копировать и его тоже. И таким образом мы скопируем весь список целиком.

Двунаправленные связанные списки делают невозможным использование одного участка памяти несколькими списками (structure sharing). Для каждого придется выделять отдельный участок памяти. А если учесть, что добавление одного элемента, это создание нового списка, то расход памяти будет очень большим.


## Стоимость операций для списков

Когда мы используем какую-либо структуру данных важно понимать стоимость различных операций для этой структуры в нотации big-O.

 - добавить элемент в начало списка - O(1);
 - добавить элемент в конец списка - O(n) и полное копирование памяти;
 - определить длину списка - O(n);
 - получить N-й элемент - O(n).

Рассмотрим суммирование двух списков:

```elixir-iex
iex(7)> [1, 2, 3] ++ [4, 5, 6]
[1, 2, 3, 4, 5, 6]
```

Стоимость этой операции O(n), где n длина первого списка. Память первого списка копируется, память второго списка используется повторно.

Тут важно, чтобы List1 был коротким, а длина List2 не важна. Часто мы не знаем длинны List1 и поэтому операцию сложения списков считаем дорогой. На 3-м уроке мы видели, как избегать этой операции с помощью **IO List**.


## Массивы

Настоящий массив, который есть в любом императивном языке, представляет собой непрерывный участок мутабельной памяти. И стоимость операций для него отличается от списка, словаря и дерева:

 - добавить элемент в начало массива - O(n), потому что все остальные элементы нужно сдвигать;
 - добавить элемент в конец массива - O(1), если хватает выделенной памяти, O(n) если памяти не хватает и нужно выделять новую;
 - определить длину массива - O(1);
 - получить/модифицировать N-й элемент - O(1).

То есть, главное преимущество таких массивов -- константное время доступа к любому элементу.


## Почему в Эликсир нет массивов

В Эликсир есть сторонняя библиотека `Arrays`, которая реализует якобы массив. На самом деле это АПИ поверх обычного словаря с целочисленными ключами.

С тем же успехом мы можем использовать словарь напрямую:

```
iex(11)> my_array = %{1 => 42, 2 => 420, 3 => 4200}
%{1 => 42, 2 => 420, 3 => 4200}
iex(12)> my_array[1]
42
iex(13)> my_array[2]
420
iex(14)> my_array[3]
4200
```

У словаря тоже константное время доступа к любому элементу. Однако, при итерации по словарю не определён порядок ключей.

В Эрланг есть модуль `:array` в стандартной библиотеке. Его свойства не описаны в документации. Но если мы попробуем его использовать:

```
iex(3)> :array.new(10)
{:array, 10, 0, :undefined, 10}
iex(4)> my_arr = :array.new(10)
{:array, 10, 0, :undefined, 10}
iex(5)> my_arr = :array.set(0, 42, my_arr)
{:array, 10, 0, :undefined,
 {42, :undefined, :undefined, :undefined, :undefined, :undefined, :undefined,
  :undefined, :undefined, :undefined}}
iex(6)> :array.get(0, my_arr)
42
iex(7)> :array.get(1, my_arr)
:undefined
iex(8)> my_arr = :array.set(1, 420, my_arr)
{:array, 10, 0, :undefined,
 {42, 420, :undefined, :undefined, :undefined, :undefined, :undefined,
  :undefined, :undefined, :undefined}}
iex(9)> my_arr = :array.set(2, 4200, my_arr)
{:array, 10, 0, :undefined,
 {42, 420, 4200, :undefined, :undefined, :undefined, :undefined, :undefined,
  :undefined, :undefined}}
```

то увидим его внутренее представление. Мы создали массив из 10 элементов, и видим, что это кортеж из 10 элементов.

Если мы создадим массив побольше:
```
iex(15)> :array.new(100)
{:array, 100, 0, :undefined, 100}
iex(16)> my_arr = :array.new(100)
{:array, 100, 0, :undefined, 100}
iex(17)> :array.set(10, 42, my_arr)
{:array, 100, 0, :undefined,
 {10,
  {42, :undefined, :undefined, :undefined, :undefined, :undefined, :undefined,
   :undefined, :undefined, :undefined}, 10, 10, 10, 10, 10, 10, 10, 10, 10}}
```
то увидим, что его внутреняя структура сложее, чем просто кортеж. На самом деле там реализовано дерево. Можно ожидать, что доступ к элементу осуществляется не за константное время, а за `O(log n)`, что характерно для деревьев.

Для реализации иммутабельных массивов требуется полное копирование памяти при любом изменении в данных, что делает такую реализацию неэффективной. Поэтому их нет в Эликсир.
