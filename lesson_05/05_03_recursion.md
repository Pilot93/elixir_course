# Рекурсия

В Эликсир, как и во всех функциональных языках, нет циклов. Их заменяет рекурсия.


## Пример 1

Начнем сразу с практики, рассмотрим пример функции, которая вычисляет длину списка:

```
def len([]), do: 0

def len([_head | tail]) do
  1 + len(tail)
end
```

Функция `len` состоит из двух тел. Первое тело вызывается на пустом списке, и это наше условие выхода из рекурсии. Здесь все просто -- длина пустого списка 0. Второе тело вызывается на непустом списке, и это один шаг (одна итерация) обработки списка.

Здесь мы делаем классическое для функционального программирования разделения списка на голову и хвост:

```elixir
[_head | tail]
```

(Переменная `_head` в дальнейшем не используется, поэтому её имя начинается с подчеркивания). Здесь логика тоже очень простая: длина списка -- это 1 плюс длина хвоста списка.


```elixir-iex
iex(1)> c "lib/recursion.exs"
[Recursion]
iex(2)> alias Recursion, as: R
iex(3)> R.len([1, 2, 3, 4, 5])
5
iex(4)> R.len([])
0
```

На каждой итерации список уменьшается на один элемент, пока не становится пустым. А пустой список попадает в первое тело функции, что завершает рекурсию.

Для списка `[1, 2, 3, 4, 5]` стек вызовов функции будет выглядеть так:

```elixir
len([1, 2, 3, 4, 5])
1 + len([2, 3, 4, 5])
1 + 1 + len([3, 4, 5])
1 + 1 + 1 + len([4, 5])
1 + 1 + 1 + 1 + len([5])
1 + 1 + 1 + 1 + 1 + len([])
1 + 1 + 1 + 1 + 1 + 0
```

## Пример 2

Возьмем пример немного сложнее, реализуем функцию, которая возвращает максимальный элемент в списке.

```
def list_max([]), do: nil

def list_max([elem]), do: elem

def list_max([head | tail]) do
  max(head, list_max(tail))
end
```

Нюанс в том, что в пустом списке нет максимального элемента, так что нужно вернуть `nil`.

Для списка из одного элемента очевидно, что этот элемент и есть максимальный элемент.

Третье тело функции реализует шаг итерации на списке, содержащем больше одного элемента. Опять делим список на голову и хвост. Чтобы найти максимальный элемент, нужно сравнить голову с максимальным элементом хвоста.


```elixir-iex
iex(5)> r R
iex(6)> R.list_max([1, 3, 33, 42, 100500, -10])
100500
iex(7)> R.list_max([1])
1
iex(8)> R.list_max([])
nil
```

Для списка `[1, 3, 33, 42]` стек вызовов будет выглядеть так:

```elixir
list_max([1, 3, 33, 42])
max(1, list_max([3, 33, 42]))
max(1, max(3, list_max([33, 42])))
max(1, max(3, max(33, list_max([42]))))
max(1, max(3, max(33, 42)))
max(1, max(3, 42))
max(1, 42)
42
```

## Пример 3

Реализуем функцию, которая меняет значение n-го элемента списка.

```
def set_value([], _position, _value), do: []

def set_value([_head | tail], 1, value), do: [value | tail]

def set_value([head | tail], position, value) do
  [head | set_value(tail, position - 1, value)]
end
```

Здесь мы пошагово уменьшаем список, пока не дойдём до нужного элемента. Затем меняем head на новое значение и собираем список обратно. Индексация сделана от единицы, но можно было бы сделать и от нуля.

Для такой функции важно подумать, что делать, если позиция выходит за пределы списка. В нашей реализации список возвращается неизменённым. А можно было бы генерировать исключение.

```
iex(1)> R.set_value([1,2,3,4], 2, 22)
[1, 22, 3, 4]
iex(2)> R.set_value([1,2,3,4], 3, 33)
[1, 2, 33, 4]
iex(3)> R.set_value([1,2,3,4], 5, 55)
[1, 2, 3, 4]
iex(4)> R.set_value([1,2,3,4], 1, 11)
[11, 2, 3, 4]
iex(5)> R.set_value([1,2,3,4], 0, 10)
[1, 2, 3, 4]
```


## Пример 4

Реализуем функцию, которая принимает два числа, задающих диапазон, и возвращает список, заполненный числами в этом диапазоне.

```
def range(from, to) when from <= to do
  [from | range(from + 1, to)]
end

def range(_, _), do: []
```

Особенность этой функции в том, что выход рекурсии здесь реализован во втором теле, а не в первом. Так тоже бывает, хоть и не часто.

```elixir-iex
iex(9)> r R
iex(10)> R.range(1, 5)
[1, 2, 3, 4, 5]
iex(11)> R.range(2, 2)
[2]
iex(12)> R.range(3, 2)
[]
```

## Пример 5

Реализуем функцию, которая меняет местами пары чисел в списке.

```
def swap_pair([]), do: []

def swap_pair([_]), do: raise "Can't swap a list with an odd number of elements"

def swap_pair([a, b | tail]) do
  [b, a | swap_pair(tail)]
end
```

Здесь две особенности. Во-первых, функция извлекает не одну голову из списка, а сразу две. Оператор `cons` позволяет извлекать одновременно несколько элементов. Во-вторых, функция предъявляет требование к входящим данным -- список должен иметь четное количество элементов.


```elixir-iex
iex(13)> r R
iex(14)> R.swap_pair([1, 2, 3, 4])
[2, 1, 4, 3]
iex(15)> R.swap_pair([1, 2, 3])
** (RuntimeError) Can't swap a list with an odd number of elements
```

## Стратегии рекурсии

TODO тема не раскрыта

**Decrease and conquer**

Постепенное уменьшение задачи шаг за шагом, приходящее к тривиальному случаю.

Все примеры выше относятся к этой стратегии.

**Divide and conquer**

Разделяем задачу на две (или больше) частей, каждую из которых можно решать независимо, затем объединяем полученные результаты.

Хорошим примером этой стратегии является алгоритмы сортировки **quick sort** и **merge sort**.

Однако, алгоритмы сортировки являются слабым местом функционального программирования. И сама по себе структура List для этого плохо подходит, и иммутабельность в данном случае мешает.

Еще хороший пример стратегии divide and conquer -- рекурсивная обработка древовидных структур данных.
