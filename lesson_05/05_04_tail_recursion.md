# Хвостовая рекурсия

В функциональных языках рекурсия заменяет циклы, характерные для императивных языков. Но в отличие от циклов, при использовании рекурсии растёт потребление памяти на стеке. Каждый шаг рекурсии сохраняется, чтобы к нему можно было вернуться и продолжить вычисления.

Во многих языках программирования глубина рекурсии ограничена. В Эликсире она не ограничена, и можно делать миллионы рекурсивных вызовов. Но, всё-таки, доступная память не бесконечна, рано или поздно она закончится.

Функциональные языки решают эту проблему с помощью **оптимизации хвостовой рекурсии**.

Если рекурсивный вызов является последним выражением в данной функции, и после него больше никаких инструкций нет, то такой вызов называется хвостовым. Получив результат функции, больше никаких действий делать не нужно, кроме как вернуть этот результат. Тогда не нужно сохранять состояние каждого шага рекурсии, а можно переиспользовать один и тот же участок стека.

Не хвостовая рекурсия:
```
def my_fun(arg):
  do_something
  b = my_fun(arg)
  do_something_else
```

Хвостовая рекурсия:
```
def my_fun(arg):
  do_something
  do_something_else
  my_fun(arg)
```

Это позволяет делать бесконечную рекурсию, которая нужна для бесконечно живущих процессов. А такие процессы нужны серверам :)

Если нам нужна бесконечная, или очень долгая рекурсия (миллионы итераций), то без хвостовой рекурсии не обойтись. Но если мы уверены, что у нас будет конечное и не очень большое число итераций, то можно выбрать вариант без неё.


## Факториал

Возьмём учебный пример рекурсии -- вычисление факториала. Реализуем его двух видах.

Без хвостовой рекурсии:

```elixir
defmodule Factorial do

  def factorial(0), do: 1
  def factorial(n) when is_integer(n) and n > 0 do
    n * factorial(n - 1)
  end
end
```

И с хвостовой рекурсией:
```
  def factorial_t(n) do
    factorial_t(n, 1)
  end

  defp factorial_t(0, acc), do: acc
  defp factorial_t(n, acc) do
    factorial_t(n - 1, n * acc)
  end
```

В первом случае мы видим, что после вызова `factorial(n - 1)` нужно вернуться обратно по стеку и выполнить `n * res`.

В таком виде это более наглядно:
```
  def factorial(n) when is_integer(n) and n > 0 do
    res = factorial(n - 1)
    n * res
  end
```

Во втором случае мы передаём промежуточный результат как второй аргумент функции. Такой стиль кода называется "рекурсия с аккумулятором" (и эта тема следущего занятия). Тут второй аргумент называется "аккумулятором", потому что он "накапливает" в себе результат вычисления.

Вот более наглядный вариант:
```
  defp factorial_t(n, accumulator) do
    current_result = n * accumulator
    factorial_t(n - 1, current_result)
  end
```

Нам важно увидеть, как используется память. Это можно увидеть с помощью функции:

```elixir
:erlang.process_info(self(), :memory)
```

Она показывает разные метрики текущего процесса, в том числе потребление памяти.

Добавим этот вызов на каждый 1000-й шаг рекурсии:

```elixir
defmodule TailRecursion do

  def factorial(0), do: 1
  def factorial(n) when is_integer(n) and n > 0 do
    if rem(n, 1000) == 0, do: report_memory()
    n * factorial(n - 1)
  end

  def factorial_t(n) do
    factorial_t(n, 1)
  end

  defp factorial_t(0, acc), do: acc
  defp factorial_t(n, acc) do
    if rem(n, 1000) == 0, do: report_memory()
    factorial_t(n - 1, n * acc)
  end

  defp report_memory() do
    data = :erlang.process_info(self(), [:memory, :total_heap_size, :stack_size])
    IO.puts("memory #{data[:memory]}, heap #{data[:total_heap_size]}, stack #{data[:stack_size]}")
  end

end
```

И чтобы отсечь внутренее состояние процесса shell, будем запускать вычисление факториала в отдельном процессе:

```elixir
iex(16)> spawn(Factorial, :factorial, [20_000])
#PID<0.136.0>
memory 2688, heap 233, stack 7
memory 55000, heap 6772, stack 6007
memory 142672, heap 17731, stack 12007
memory 230344, heap 28690, stack 18007
memory 230344, heap 28690, stack 24007
memory 372200, heap 46422, stack 30007
memory 372200, heap 46422, stack 36007
memory 372200, heap 46422, stack 42007
memory 601728, heap 75113, stack 48007
memory 601728, heap 75113, stack 54007
memory 601728, heap 75113, stack 60007
memory 601728, heap 75113, stack 66007
memory 601728, heap 75113, stack 72007
memory 973112, heap 121536, stack 78007
memory 973112, heap 121536, stack 84007
memory 973112, heap 121536, stack 90007
memory 973112, heap 121536, stack 96007
memory 973112, heap 121536, stack 102007
memory 973112, heap 121536, stack 108007
memory 973112, heap 121536, stack 114007

iex(17)> spawn(Factorial, :factorial_t, [20_000])
#PID<0.138.0>
memory 2688, heap 233, stack 8
memory 907040, heap 113277, stack 8
memory 2686696, heap 335734, stack 8
memory 12085240, heap 1510552, stack 8
memory 13841864, heap 1730130, stack 8
memory 15587544, heap 1948340, stack 8
memory 17321528, heap 2165088, stack 8
memory 19043112, heap 2380286, stack 8
memory 20751312, heap 2593811, stack 8
memory 22445040, heap 2805527, stack 8
memory 24123064, heap 3015280, stack 8
memory 25783880, heap 3222882, stack 8
memory 27425672, heap 3428106, stack 8
memory 29046264, heap 3630680, stack 8
memory 30642456, heap 3830204, stack 8
memory 32210896, heap 4026259, stack 8
memory 33746272, heap 4218181, stack 8
memory 35241072, heap 4405031, stack 8
memory 36683160, heap 4585292, stack 8
memory 38049928, heap 4756138, stack 8
```

Тут мы видим, что стек ведет себя как должен -- растет в реализации без хвостовой рекурсии, и не растет в хвостовой. При этом быстро растет память в куче. И хвостовая рекурсия потребляет в 40 раз больше памяти.

Если посмотреть на результат вычисления факториала от 20_000, то это будет огромное число на много экранов, которое нужно долго скролить, чтобы увидеть все целиком. Очевидно, что такое число не помещается на стеке, и память для него выделяется в куче. Можно предположить, что хвостовая рекурсия хранит много таких промежуточных результатов, пока их не почистит сборщик мусора, и поэтому потребляет больше памяти.


## Сумма всех элементов списка

Возьмем простую рекурсию, где аккумулятор не будет хранить такие огромные данные, как у факториала, а шаги рекурсии будут простыми.

```elixir
  def sum([]), do: 0
  def sum([head | tail]) do
    report_memory()
    head + sum(tail)
  end

  def sum_t(list) do
    sum_t(list, 0)
  end

  def sum_t([], acc), do: acc
  def sum_t([head | tail], acc) do
    report_memory()
    sum_t(tail, head + acc)
  end
```

Что получится?

```elixir-iex
iex(32)> list = Enum.to_list(0..100)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
 42, 43, 44, 45, 46, 47, 48, 49, ...]
iex(5)> R.sum(list)
memory 34460, heap 4184, stack 59
memory 34460, heap 4184, stack 61
memory 34460, heap 4184, stack 63
...
memory 29572, heap 3573, stack 255
memory 29572, heap 3573, stack 257
memory 29572, heap 3573, stack 259
5050
iex(6)> R.sum_t(list)
memory 29572, heap 3573, stack 60
memory 29572, heap 3573, stack 60
memory 29572, heap 3573, stack 60
...
memory 42364, heap 5172, stack 60
memory 42364, heap 5172, stack 60
memory 42364, heap 5172, stack 60
5050
```

Вот теперь наглядно видно, как растет стек. Куча при этом меняется не сильно, и может даже уменьшаться. Очевидно из-за сборки мусора.


## Вывод

В книгах нередко пишут, что хвостовая рекурсия эффективнее. Мы уже убедились, что на практике это не всегда так, и каждый конкретный случай нужно проверять.

В документации по Эрланг есть раздел Efficiency Guide о том, как писать эффективный код. Помимо прочего, там разбирается и хвостовая рекурсия:
[The Seven Myths of Erlang Performance](https://erlang.org/doc/efficiency_guide/myths.html). Разумеется, это справедливо и для Эликсир.

Код без хвостовой рекурсии часто получается короче и проще, а иногда и лучше по производительности.
