# Рекурсивные функции с аккумуляторами

Рассмотрим несколько типовых примеров работы со списками, которые используют рекурсию с аккумулятором.

В примерах мы будем использовать список неких пользователей, где каждый пользователь представлен кортежем из 4-х элементов:

```
  def test_data() do
    # {:user, id, name, age}
    [
      {:user, 1, "Bob", 23},
      {:user, 2, "Helen", 20},
      {:user, 3, "Bill", 15},
      {:user, 4, "Kate", 14}
    ]
  end
```

## Пример 1

Отфильтруем список по возрасту -- выберем только пользователей старше 16 лет.

Применим уже известный подход из двух функций -- публичная функция без аккумулятора и приватная функция с аккумулятором.

```
  def filter_adults(users), do: filter_adults(users, [])

  defp filter_adults([], acc), do: Enum.reverse(acc)

  defp filter_adults([user | users], acc) do
    {:user, _, _, age} = user
    if age > 16 do
      filter_adults(users, [user | acc])
    else
      filter_adults(users, acc)
    end
  end
```

Приватная функция получает на вход два аргумента: список пользователей и ещё один список, где будет накапливаться результат выполнения -- аккумулятор.

В начале список пользователей полный, а аккумулятор пустой. На каждом шаге итерации мы будем брать один элемент из первого списка и, если он нам нужен, класть его в аккумулятор. В итоге первый список опустошится, а аккумулятор наполнится.

Наша рекурсивная функция имеет два тела. Первое тело выполняется, когда список пользователей пустой. То есть, это завершение фильтрации. И тут нужно просто отдать накопленный результат.

Второе тело и делает всю работу. Сперва список пользователей с помощью оператора cons делится на голову и хвост (это можно делать прямо в описании аргументов функции).  Голова -- это текущий элемент списка, который мы будем анализировать. Хвост -- это остаток списка, который мы передадим дальше, в следующий рекурсивный вызов.

Анализ элемента тут простой: определяем возраст пользователя. Пользователей младше 16 лет мы игнорируем, а старше добавляем в аккумулятор, опять же с помощью оператора cons.

Элементы в аккумуляторе накапливаются в обратном порядке. Если это не важно, то аккумулятор можно вернуть, как есть. Если желательно сохранить оригинальный порядок, то аккумулятор нужно развернуть.

```
iex(4)> RA.filter_adults(users)
[{:user, 2, "Helen", 20}, {:user, 1, "Bob", 23}]
```

## Пример 2

Второй пример. Допустим, из списка пользователей нужно извлечь их идентификаторы и имена. То есть получить список кортежей вида:

```elixir
{id, name}
```

Делаем:

```
  def get_id_name(users), do: get_id_name(users, [])

  defp get_id_name([], acc), do: Enum.reverse(acc)

  defp get_id_name([user | users], acc) do
    {:user, id, name, _} = user
    get_id_name(users, [{id, name} | acc])
  end
```

Опять два тела у функции. Первое тело отвечает за завершение рекурсии и возврат результата, накопленного в аккумуляторе.

Второе тело обрабатывает каждый элемент списка, извлекает из кортежа нужные id и name и сохраняет их в аккумуляторе.

```elixir-iex
iex(5)> RA.get_id_name(users)
[{1, "Bob"}, {2, "Helen"}, {3, "Bill"}, {4, "Kate"}]
```

## Пример 3

Аккумулятор может быть более сложной структурой данных, чем просто плоский список.

Допустим нам нужно разделить пользователей на два списка: несовершеннолетние и взрослые.

```
  def split_teens_and_adults(users), do: split_teens_and_adults(users, {[], []})

  defp split_teens_and_adults([], {teens, adults}) do
    {Enum.reverse(teens), Enum.reverse(adults)}
  end

  defp split_teens_and_adults([user | users], {teens, adults}) do
    {:user, _, _, age} = user
    if age > 16 do
      split_teens_and_adults(users, {teens, [user | adults]})
    else
      split_teens_and_adults(users, {[user | teens], adults})
    end
  end
```

В этот раз наш аккумулятор -- это кортеж из двух списков. В первом теле функции, как обычно, возвращаем результат. И тут мы разворачиваем оба списка.

Во втором теле функции обрабатываем каждый элемент списка, извлекаем и проверяем возраст. Тех, кто моложе 16 лет, кладем в первый список в аккумуляторе, остальных -- во второй список.

```
iex(6)> TA.split_teens_and_adults(users)
{[{:user, 3, "Bill", 15}, {:user, 4, "Kate", 14}],
 [{:user, 1, "Bob", 23}, {:user, 2, "Helen", 20}]}
```

В данном случае можно было бы применять два аргумента-аккумулятора:

```
defp my_fum(dat, acc1, acc2) do
```

Но один аккумулятор позволяет перейти к функциям высшего порядка, что будет темой следущего урока.


## Пример 4

Бывает и наоборот -- очень простой аккумулятор.

Давайте посчитаем средний возраст всех пользователей.

```
  def get_avg_age(users) do
    total_age = get_total_age(users, 0)
    total_users = length(users)
    total_age / total_users
  end

  defp get_total_age([], total_age), do: total_age

  defp get_total_age([user | users], total_age) do
    {:user, _, _, age} = user
    get_total_age(users, age + total_age)
  end
```

Здесь аккумулятор -- это просто число.

```
iex(22)> R.get_avg_age(users)
22.8
```

