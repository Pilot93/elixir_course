## Алгебраические типы данных

Теперь немного теории. В функциональном программировании есть понятие Алгебраических типов данных, ADT (Algebraic data type). Суть их в том, что для данных определены некоторые алгебраические операции, позволяющие создавать более сложные данные.

Например, Event -- это название И время И место И участники И агенда. Это **произведение (умножение, product)** данных.

Самое простое произведение -- это кортеж:

```elixir
{:event, "Team Meeting", datetime, location, participants, agenda}
```

В языке OCaml тип кортежа так и обозначается -- через знак умножения:

```
String * Datetime * Participant list * Topic list
```

Struct -- это тоже произведение:

```elixir
%Event.Event{
  title: "Team Meeting",
  datetime: ~U[2021-03-10 19:40:00.000000Z],
  location: location,
  participants: [helen, bob, kate, tihon],
  agenda: agenda
}
```

Теперь посмотрим на `%Event.Participant.species` и `%Event.Participant.role`.
В нашем примере встречаются два вида species -- это `:human` ИЛИ `:cat`.
И встречаются три вида role -- это `:project_manager` ИЛИ `:developer` ИЛИ `:cat`.

Это **перечисление (сумма, sum)** данных.

Во многих языках для этого есть тип Enum, который определяет конечное множество значений. Например, в OCaml это было бы так:

```
data Species = Human | Cat
data Role = ProjectManager | Developer | Cat
```

И компилятор не позволит присвоить какие-либо другие значения, кроме перечисленных.

К сожалению, в Эликсир нет типа Enum на уровне компилятора. Но можно описать этот тип для dialyzer:

```elixir
@type species :: :human | :cat
@type role :: :project_manager | :developer | :cat
```

(Зато в Elixir есть модуль Enum, что вносит некоторую путаницу. Название совсем неудачное, правильно было бы назвать этот модуль -- Collection).

Произведение и сумма (product & sum) позволяют описать любые объекты. Раньше мы говорили, что кортеж и список позволяют моделировать любые объекты. ADT -- это другой уровень абстракции. На этом уровне не различаются одиночный элемент и список элементов. Зато определяются способы композиции данных для создания новых, более сложных данных.

Какая же от всего этого польза? Это математический аппарат, который используется при создании системы типов в некоторых языках программирования, особенно в функциональных языках.

В языках с полноценной реализацией ADT (это, например, OCaml, Haskell, Scala, F#), при применении pattern matching к типу Enum проверяется, что в шаблонах использованы все возможные значения:

```elixir
case tihon.species do
  :human -> do_something
  :cat -> do_something_else
end

case tihon.role do
  :cat -> do_something
  :developer -> do_something_else
end
```

В таких языках первый пример скомпилировался бы успешно, а во втором примере компилятор выдал бы ошибку, что не использовано значение :project_manager. Это важно при изменениях в данных, когда добавляется новое значение в Enum, и нужно найти и обновить все места в коде, где эти данные обрабатываются.

Увы, Elixir и dialyzer этого не делают.
